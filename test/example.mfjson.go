// Code generated by mfjson for marshaling/unmarshaling. DO NOT EDIT.
// https://github.com/myfantasy/json

package testex

import (
	"encoding/json"

	"github.com/myfantasy/mft"

	mfj "github.com/myfantasy/json"

	log "github.com/sirupsen/logrus"
)

//easyjson:json
type Example_mfjson_wrap struct {
	A int `json:"id"`

	B int64

	// C TestInt1 `json:"c" mfjson:"true"`
	C mfj.IStructView `json:"c" mfjson:"true"`

	// D mfj.JsonInterfaceMarshaller `json:"d" mfjson:"true"`
	D mfj.IStructView `json:"d" mfjson:"true"`

	// E TestInt2 `json:"e" mfjson:"true"`
	E mfj.IStructView `json:"e" mfjson:"true"`

	F log.Level

	// G []TestInt2 `json:"g" mfjson:"true"`
	G []mfj.IStructView `json:"g" mfjson:"true"`

	// H map[string]TestInt2 `json:"h" mfjson:"true"`
	H map[string]mfj.IStructView `json:"h" mfjson:"true"`

	K []log.Level

	L map[int]log.Level

	M [][]*log.Level

	N *log.Level

	O [4]*log.Level

	// P TestInt2 `json:"p" mfjson:"true"`
	P mfj.IStructView `json:"p" mfjson:"true"`

	// Q TestInt2 `json:"q" mfjson:"true"`
	Q mfj.IStructView `json:"q" mfjson:"true"`
}

func (obj Example) MarshalJSON() (res []byte, err error) {
	out := Example_mfjson_wrap{}
	out.A = obj.A
	out.B = obj.B
	{
		if ujo, ok := obj.C.(mfj.JsonInterfaceMarshaller); ok {
			sw := mfj.IStructView{}
			sw.Type = ujo.UnmarshalJSONTypeName()
			sw.Data, err = json.Marshal(obj.C)
			out.C = sw
		} else {
			out.C = mfj.IStructView{}
		}
	}
	{
		if ujo, ok := obj.D.(mfj.JsonInterfaceMarshaller); ok {
			sw := mfj.IStructView{}
			sw.Type = ujo.UnmarshalJSONTypeName()
			sw.Data, err = json.Marshal(obj.D)
			out.D = sw
		} else {
			out.D = mfj.IStructView{}
		}
	}
	{
		if ujo, ok := obj.E.(mfj.JsonInterfaceMarshaller); ok {
			sw := mfj.IStructView{}
			sw.Type = ujo.UnmarshalJSONTypeName()
			sw.Data, err = json.Marshal(obj.E)
			out.E = sw
		} else {
			out.E = mfj.IStructView{}
		}
	}
	out.F = obj.F
	{
		if obj.G == nil {
			out.G = nil
		} else {
			swl := make([]mfj.IStructView, len(obj.G))
			for i := 0; i < len(obj.G); i++ {
				if ujo, ok := obj.G[i].(mfj.JsonInterfaceMarshaller); ok {
					sw := mfj.IStructView{}
					sw.Type = ujo.UnmarshalJSONTypeName()
					sw.Data, err = json.Marshal(obj.G[i])
					swl[i] = sw
				} else {
					swl[i] = mfj.IStructView{}
				}
			}
			out.G = swl
		}
	}
	{
		if obj.H == nil {
			out.H = nil
		} else {
			swl := make(map[string]mfj.IStructView, len(obj.H))
			for k, v := range obj.H {
				if ujo, ok := v.(mfj.JsonInterfaceMarshaller); ok {
					sw := mfj.IStructView{}
					sw.Type = ujo.UnmarshalJSONTypeName()
					sw.Data, err = json.Marshal(v)
					if err != nil {
						return nil, err
					}
					swl[k] = sw
				} else {
					swl[k] = mfj.IStructView{}
				}
			}
			out.H = swl
		}
	}
	out.K = obj.K
	out.L = obj.L
	out.M = obj.M
	out.N = obj.N
	out.O = obj.O
	{
		if ujo, ok := obj.P.(mfj.JsonInterfaceMarshaller); ok {
			sw := mfj.IStructView{}
			sw.Type = ujo.UnmarshalJSONTypeName()
			sw.Data, err = json.Marshal(obj.P)
			out.P = sw
		} else {
			out.P = mfj.IStructView{}
		}
	}
	{
		if ujo, ok := obj.Q.(mfj.JsonInterfaceMarshaller); ok {
			sw := mfj.IStructView{}
			sw.Type = ujo.UnmarshalJSONTypeName()
			sw.Data, err = json.Marshal(obj.Q)
			out.Q = sw
		} else {
			out.Q = mfj.IStructView{}
		}
	}
	return json.Marshal(out)
}
func (obj *Example) UnmarshalJSON(data []byte) (err error) {
	tmp := Example_mfjson_wrap{}
	if data == nil {
		return nil
	}
	err = json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}
	obj.A = tmp.A
	obj.B = tmp.B
	{
		if tmp.C.Type == "" {
			obj.C = nil
		} else if tmp.C.Data == nil {
			to, er0 := mfj.GlobalStructFactory.GetNil(tmp.C.Type)
			if er0 != nil {
				return er0
			}
			toTrans, ok := to.(TestInt1)
			if !ok {
				return mft.ErrorS("Type 'TestInt1' not valid in generations 'Example.C' (NIL)")
			}
			obj.C = toTrans
		} else {
			to, er0 := mfj.GlobalStructFactory.Get(tmp.C.Type)
			if er0 != nil {
				return er0
			}
			toTrans, ok := to.(TestInt1)
			if !ok {
				return mft.ErrorS("Type 'TestInt1' not valid in generations 'Example.C'")
			}
			err = json.Unmarshal(tmp.C.Data, &toTrans)
			if err != nil {
				return err
			}
			obj.C = toTrans
		}
	}
	{
		if tmp.D.Type == "" {
			obj.D = nil
		} else if tmp.D.Data == nil {
			to, er0 := mfj.GlobalStructFactory.GetNil(tmp.D.Type)
			if er0 != nil {
				return er0
			}
			toTrans, ok := to.(mfj.JsonInterfaceMarshaller)
			if !ok {
				return mft.ErrorS("Type 'mfj.JsonInterfaceMarshaller' not valid in generations 'Example.D' (NIL)")
			}
			obj.D = toTrans
		} else {
			to, er0 := mfj.GlobalStructFactory.Get(tmp.D.Type)
			if er0 != nil {
				return er0
			}
			toTrans, ok := to.(mfj.JsonInterfaceMarshaller)
			if !ok {
				return mft.ErrorS("Type 'mfj.JsonInterfaceMarshaller' not valid in generations 'Example.D'")
			}
			err = json.Unmarshal(tmp.D.Data, &toTrans)
			if err != nil {
				return err
			}
			obj.D = toTrans
		}
	}
	{
		if tmp.E.Type == "" {
			obj.E = nil
		} else if tmp.E.Data == nil {
			to, er0 := mfj.GlobalStructFactory.GetNil(tmp.E.Type)
			if er0 != nil {
				return er0
			}
			toTrans, ok := to.(TestInt2)
			if !ok {
				return mft.ErrorS("Type 'TestInt2' not valid in generations 'Example.E' (NIL)")
			}
			obj.E = toTrans
		} else {
			to, er0 := mfj.GlobalStructFactory.Get(tmp.E.Type)
			if er0 != nil {
				return er0
			}
			toTrans, ok := to.(TestInt2)
			if !ok {
				return mft.ErrorS("Type 'TestInt2' not valid in generations 'Example.E'")
			}
			err = json.Unmarshal(tmp.E.Data, &toTrans)
			if err != nil {
				return err
			}
			obj.E = toTrans
		}
	}
	obj.F = tmp.F
	{
		if tmp.G == nil {
			obj.G = nil
		} else {
			obj.G = make([]TestInt2, len(tmp.G))
			for i := 0; i < len(tmp.G); i++ {
				if tmp.G[i].Type == "" {
					obj.G[i] = nil
				} else if tmp.G[i].Data == nil {
					to, er0 := mfj.GlobalStructFactory.GetNil(tmp.G[i].Type)
					if er0 != nil {
						return er0
					}
					toTrans, ok := to.(TestInt2)
					if !ok {
						return mft.ErrorS("Type 'G' not valid in generations 'TestInt2..Example' (NIL)")
					}
					obj.G[i] = toTrans
				} else {
					to, er0 := mfj.GlobalStructFactory.Get(tmp.G[i].Type)
					if er0 != nil {
						return er0
					}
					toTrans, ok := to.(TestInt2)
					if !ok {
						return mft.ErrorS("Type 'TestInt2' not valid in generations 'Example..G'")
					}
					err = json.Unmarshal(tmp.G[i].Data, &toTrans)
					if err != nil {
						return err
					}
					obj.G[i] = toTrans
				}
			}
		}
	}
	{
		if tmp.H == nil {
			obj.H = nil
		} else {
			obj.H = make(map[string]TestInt2, len(tmp.H))
			for k, v := range tmp.H {
				if v.Type == "" {
					obj.H[k] = nil
				} else if v.Data == nil {
					to, er0 := mfj.GlobalStructFactory.GetNil(v.Type)
					if er0 != nil {
						return er0
					}
					toTrans, ok := to.(TestInt2)
					if !ok {
						return mft.ErrorS("Type 'H' not valid in generations 'TestInt2[]Example' (NIL)")
					}
					obj.H[k] = toTrans
				} else {
					to, er0 := mfj.GlobalStructFactory.Get(v.Type)
					if er0 != nil {
						return er0
					}
					toTrans, ok := to.(TestInt2)
					if !ok {
						return mft.ErrorS("Type 'TestInt2' not valid in generations 'Example[]H'")
					}
					err = json.Unmarshal(v.Data, &toTrans)
					if err != nil {
						return err
					}
					obj.H[k] = toTrans
				}
			}
		}
	}
	obj.K = tmp.K
	obj.L = tmp.L
	obj.M = tmp.M
	obj.N = tmp.N
	obj.O = tmp.O
	{
		if tmp.P.Type == "" {
			obj.P = nil
		} else if tmp.P.Data == nil {
			to, er0 := mfj.GlobalStructFactory.GetNil(tmp.P.Type)
			if er0 != nil {
				return er0
			}
			toTrans, ok := to.(TestInt2)
			if !ok {
				return mft.ErrorS("Type 'TestInt2' not valid in generations 'Example.P' (NIL)")
			}
			obj.P = toTrans
		} else {
			to, er0 := mfj.GlobalStructFactory.Get(tmp.P.Type)
			if er0 != nil {
				return er0
			}
			toTrans, ok := to.(TestInt2)
			if !ok {
				return mft.ErrorS("Type 'TestInt2' not valid in generations 'Example.P'")
			}
			err = json.Unmarshal(tmp.P.Data, &toTrans)
			if err != nil {
				return err
			}
			obj.P = toTrans
		}
	}
	{
		if tmp.Q.Type == "" {
			obj.Q = nil
		} else if tmp.Q.Data == nil {
			to, er0 := mfj.GlobalStructFactory.GetNil(tmp.Q.Type)
			if er0 != nil {
				return er0
			}
			toTrans, ok := to.(TestInt2)
			if !ok {
				return mft.ErrorS("Type 'TestInt2' not valid in generations 'Example.Q' (NIL)")
			}
			obj.Q = toTrans
		} else {
			to, er0 := mfj.GlobalStructFactory.Get(tmp.Q.Type)
			if er0 != nil {
				return er0
			}
			toTrans, ok := to.(TestInt2)
			if !ok {
				return mft.ErrorS("Type 'TestInt2' not valid in generations 'Example.Q'")
			}
			err = json.Unmarshal(tmp.Q.Data, &toTrans)
			if err != nil {
				return err
			}
			obj.Q = toTrans
		}
	}
	return nil
}

type AasList_mfjson_wrap []mfj.IStructView

func (obj AasList) MarshalJSON() (res []byte, err error) {
	if obj == nil {
		var out AasList_mfjson_wrap
		return json.Marshal(out)
	}
	out := make(AasList_mfjson_wrap, len(obj))
	swl := make([]mfj.IStructView, len(obj))
	for i := 0; i < len(obj); i++ {
		if ujo, ok := obj[i].(mfj.JsonInterfaceMarshaller); ok {
			sw := mfj.IStructView{}
			sw.Type = ujo.UnmarshalJSONTypeName()
			sw.Data, err = json.Marshal(obj[i])
			swl[i] = sw
		} else {
			swl[i] = mfj.IStructView{}
		}
	}

	return json.Marshal(out)
}
func (obj *AasList) UnmarshalJSON(data []byte) (err error) {
	if data == nil {
		return nil
	}
	var tmp AasList_mfjson_wrap
	err = json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}
	if tmp == nil {
		var d AasList
		*obj = d
		return nil
	}
	objRaw := make(AasList, len(tmp))
	*obj = objRaw
	for i := 0; i < len(tmp); i++ {
		if tmp[i].Type == "" {
			objRaw[i] = nil
		} else if tmp[i].Data == nil {
			to, er0 := mfj.GlobalStructFactory.GetNil(tmp[i].Type)
			if er0 != nil {
				return er0
			}
			toTrans, ok := to.(TestInt1)
			if !ok {
				return mft.ErrorS("Type 'TestInt1' not valid in generations 'AasList' (ARR, NIL)")
			}
			objRaw[i] = toTrans
		} else {
			to, er0 := mfj.GlobalStructFactory.Get(tmp[i].Type)
			if er0 != nil {
				return er0
			}
			toTrans, ok := to.(TestInt1)
			if !ok {
				return mft.ErrorS("Type 'TestInt1' not valid in generations 'AasList' (ARR)")
			}
			err = json.Unmarshal(tmp[i].Data, &toTrans)
			if err != nil {
				return err
			}
			objRaw[i] = toTrans
		}
	}
	return nil
}

//easyjson:json
type AasMap_mfjson_wrap map[string]mfj.IStructView

func (obj AasMap) MarshalJSON() (res []byte, err error) {
	if obj == nil {
		var out AasMap_mfjson_wrap
		return json.Marshal(out)
	}
	swl := make(map[string]mfj.IStructView, len(obj))
	for k, v := range obj {
		if ujo, ok := v.(mfj.JsonInterfaceMarshaller); ok {
			sw := mfj.IStructView{}
			sw.Type = ujo.UnmarshalJSONTypeName()
			sw.Data, err = json.Marshal(v)
			if err != nil {
				return nil, err
			}
			swl[k] = sw
		} else {
			swl[k] = mfj.IStructView{}
		}
	}

	return json.Marshal(swl)
}
func (obj *AasMap) UnmarshalJSON(data []byte) (err error) {
	if data == nil {
		return nil
	}
	var tmp AasMap_mfjson_wrap
	err = json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}
	if tmp == nil {
		var d AasMap
		*obj = d
		return nil
	}
	objRaw := make(AasMap, len(tmp))
	*obj = objRaw
	for k, v := range tmp {
		if v.Type == "" {
			objRaw[k] = nil
		} else if v.Data == nil {
			to, er0 := mfj.GlobalStructFactory.GetNil(v.Type)
			if er0 != nil {
				return er0
			}
			toTrans, ok := to.(TestInt1)
			if !ok {
				return mft.ErrorS("Type 'TestInt1' not valid in generations 'AasMap' (ARR, NIL)")
			}
			objRaw[k] = toTrans
		} else {
			to, er0 := mfj.GlobalStructFactory.Get(v.Type)
			if er0 != nil {
				return er0
			}
			toTrans, ok := to.(TestInt1)
			if !ok {
				return mft.ErrorS("Type 'TestInt1' not valid in generations 'AasMap' (ARR)")
			}
			err = json.Unmarshal(v.Data, &toTrans)
			if err != nil {
				return err
			}
			objRaw[k] = toTrans
		}
	}
	return nil
}

func (obj *B) UnmarshalJSONTypeName() string {
	return "B"
}
func (obj *C) UnmarshalJSONTypeName() string {
	return "c"
}

func init() {
	mfj.GlobalStructFactory.Add("B", func() mfj.JsonInterfaceMarshaller { return &B{} })
	mfj.GlobalStructFactory.AddNil("B", func() mfj.JsonInterfaceMarshaller {
		var out *B
		return out
	})
	mfj.GlobalStructFactory.Add("c", func() mfj.JsonInterfaceMarshaller { return &C{} })
	mfj.GlobalStructFactory.AddNil("c", func() mfj.JsonInterfaceMarshaller {
		var out *C
		return out
	})
}
